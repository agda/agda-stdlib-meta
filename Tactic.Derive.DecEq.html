<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.Derive.DecEq</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/agda/agda-stdlib-meta/tree/master///Tactic/Derive/DecEq.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Comment">-- Deriving decidable equality. This works in several cases that use</a>
<a id="70" class="Comment">-- mutual recursion, examples are at the bottom.</a>
<a id="119" class="Comment">--</a>
<a id="122" class="Comment">-- TODO: This breaks with:</a>
<a id="149" class="Comment">-- - dependent records, e.g. Product</a>
<a id="186" class="Comment">-- - anything listed in Tactic.Derive</a>
<a id="224" class="Comment">-- - maybe more</a>

<a id="241" class="Symbol">{-#</a> <a id="245" class="Keyword">OPTIONS</a> <a id="253" class="Pragma">-v</a> <a id="256" class="Pragma">allTactics:100</a> <a id="271" class="Symbol">#-}</a>
<a id="275" class="Symbol">{-#</a> <a id="279" class="Keyword">OPTIONS</a> <a id="287" class="Pragma">--safe</a> <a id="294" class="Pragma">--with-K</a> <a id="303" class="Symbol">#-}</a>
<a id="307" class="Keyword">module</a> <a id="314" href="Tactic.Derive.DecEq.html" class="Module">Tactic.Derive.DecEq</a> <a id="334" class="Keyword">where</a>

<a id="341" class="Keyword">open</a> <a id="346" class="Keyword">import</a> <a id="353" href="Meta.Prelude.html" class="Module">Meta.Prelude</a>
<a id="366" class="Keyword">open</a> <a id="371" class="Keyword">import</a> <a id="378" href="Meta.Init.html" class="Module">Meta.Init</a>

<a id="389" class="Keyword">import</a> <a id="396" href="Data.List.html" class="Module">Data.List</a> <a id="406" class="Symbol">as</a> <a id="409" class="Module">L</a>
<a id="411" class="Keyword">import</a> <a id="418" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="437" class="Symbol">as</a> <a id="440" class="Module">NE</a>

<a id="444" class="Keyword">open</a> <a id="449" class="Keyword">import</a> <a id="456" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>

<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Reflection.Tactic.html" class="Module">Reflection.Tactic</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Reflection.QuotedDefinitions.html" class="Module">Reflection.QuotedDefinitions</a>
<a id="545" class="Keyword">open</a> <a id="550" class="Keyword">import</a> <a id="557" href="Reflection.AST.DeBruijn.html" class="Module">Reflection.AST.DeBruijn</a>

<a id="582" class="Keyword">open</a> <a id="587" class="Keyword">import</a> <a id="594" href="Class.DecEq.Core.html" class="Module">Class.DecEq.Core</a>
<a id="611" class="Keyword">open</a> <a id="616" class="Keyword">import</a> <a id="623" href="Class.Functor.html" class="Module">Class.Functor</a>
<a id="637" class="Keyword">open</a> <a id="642" class="Keyword">import</a> <a id="649" href="Class.MonadTC.Instances.html" class="Module">Class.MonadTC.Instances</a>
<a id="673" class="Keyword">open</a> <a id="678" class="Keyword">import</a> <a id="685" href="Class.Traversable.html" class="Module">Class.Traversable</a>

<a id="704" class="Keyword">open</a> <a id="709" class="Keyword">import</a> <a id="716" href="Tactic.ClauseBuilder.html" class="Module">Tactic.ClauseBuilder</a>
<a id="737" class="Keyword">open</a> <a id="742" class="Keyword">import</a> <a id="749" href="Tactic.Derive.html" class="Module">Tactic.Derive</a> <a id="763" class="Symbol">(</a><a id="764" class="Keyword">quote</a> <a id="770" href="Class.DecEq.Core.html#117" class="Record">DecEq</a><a id="775" class="Symbol">)</a> <a id="777" class="Symbol">(</a><a id="778" class="Keyword">quote</a> <a id="784" href="Class.DecEq.Core.html#159" class="Field Operator">_≟_</a><a id="787" class="Symbol">)</a>


<a id="791" class="Keyword">open</a> <a id="796" href="Tactic.ClauseBuilder.html#10918" class="Module">ClauseExprM</a>

<a id="809" class="Comment">-- simply typed annotated case_of_, giving better performance than without a type annotation</a>
<a id="902" class="Comment">-- the type annotation prevents elaboration time from doubling on every argument to a constructor</a>
<a id="`case_returning_of_"></a><a id="1000" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">`case_returning_of_</a> <a id="1020" class="Symbol">:</a> <a id="1022" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1027" class="Symbol">→</a> <a id="1029" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1034" class="Symbol">→</a> <a id="1036" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1041" class="Symbol">→</a> <a id="1043" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="1048" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">`case</a> <a id="1054" href="Tactic.Derive.DecEq.html#1054" class="Bound">t</a> <a id="1056" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">returning</a> <a id="1066" href="Tactic.Derive.DecEq.html#1066" class="Bound">t&#39;</a> <a id="1069" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">of</a> <a id="1072" href="Tactic.Derive.DecEq.html#1072" class="Bound">t&#39;&#39;</a> <a id="1076" class="Symbol">=</a> <a id="1078" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="1082" class="Symbol">(</a><a id="1083" class="Keyword">quote</a> <a id="1089" href="Function.Base.html#4042" class="Function Operator">case_of_</a><a id="1097" class="Symbol">)</a> <a id="1099" class="Symbol">(</a><a id="1100" href="Reflection.Syntax.html#1352" class="InductiveConstructor">hArg?</a> <a id="1106" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1108" href="Reflection.Syntax.html#1352" class="InductiveConstructor">hArg?</a> <a id="1114" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1116" href="Reflection.Syntax.html#1352" class="InductiveConstructor">hArg?</a> <a id="1122" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1124" href="Reflection.AST.Argument.html#1391" class="InductiveConstructor">hArg</a> <a id="1129" href="Tactic.Derive.DecEq.html#1066" class="Bound">t&#39;</a> <a id="1132" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1134" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="1139" href="Tactic.Derive.DecEq.html#1054" class="Bound">t</a> <a id="1141" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1143" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="1148" href="Tactic.Derive.DecEq.html#1072" class="Bound">t&#39;&#39;</a> <a id="1152" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1154" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="1156" class="Symbol">)</a>

<a id="1159" class="Keyword">private</a>
  <a id="1169" class="Keyword">instance</a> <a id="1178" href="Tactic.Derive.DecEq.html#1178" class="Function">_</a> <a id="1180" class="Symbol">=</a> <a id="1182" href="Tactic.ClauseBuilder.html#10674" class="Function">ContextMonad-MonadTC</a>

  <a id="1206" class="Comment">-- Here&#39;s an example of what code this generates, here for a record R with 3 fields:</a>
  <a id="1293" class="Comment">-- DecEq : DecEq R</a>
  <a id="1314" class="Comment">-- DecEq ._≟_ ⟪ x₁ , x₂ , x₃ ⟫ ⟪ y₁ , y₂ , y₃ ⟫ =</a>
  <a id="1366" class="Comment">--   case (x₁ ≟ y₁) of λ where</a>
  <a id="1399" class="Comment">--     (false because ¬p) → no (case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl)</a>
  <a id="1477" class="Comment">--     (true because p₁) → case (x₂ ≟ y₂) of λ where</a>
  <a id="1532" class="Comment">--       (false because ¬p) → no (case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl)</a>
  <a id="1612" class="Comment">--       (true because p₂) → case (x₃ ≟ y₃) of λ where</a>
  <a id="1669" class="Comment">--         (false because ¬p) → no (case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl)</a>
  <a id="1751" class="Comment">--         (true because p₃) →  yes (case p₁ , p₂ , p₃ of λ where (ofʸ refl , ofʸ refl , ofʸ refl) → refl)</a>

  <a id="1861" class="Comment">-- patterns almost like `yes` and `no`, except that they don&#39;t match the `Reflects` proof</a>
  <a id="1953" class="Comment">-- delaying maching on the `Reflects` proof as late as possible results in a major speed increase</a>
  <a id="2053" class="Keyword">pattern</a> <a id="``yes&#39;"></a><a id="2061" href="Tactic.Derive.DecEq.html#2061" class="InductiveConstructor">``yes&#39;</a> <a id="2068" href="Tactic.Derive.DecEq.html#2107" class="Bound">x</a> <a id="2070" class="Symbol">=</a> <a id="2072" class="Keyword">quote</a> <a id="2078" href="Relation.Nullary.Decidable.Core.html#1905" class="InductiveConstructor Operator">_because_</a> <a id="2088" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">◇⟦</a> <a id="2091" class="Keyword">quote</a> <a id="2097" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a>  <a id="2103" href="Reflection.Syntax.html#3281" class="InductiveConstructor Operator">◇</a> <a id="2105" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">∣</a> <a id="2107" href="Tactic.Derive.DecEq.html#2107" class="Bound">x</a> <a id="2109" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">⟧</a>
  <a id="2113" class="Keyword">pattern</a> <a id="``no&#39;"></a><a id="2121" href="Tactic.Derive.DecEq.html#2121" class="InductiveConstructor">``no&#39;</a>  <a id="2128" href="Tactic.Derive.DecEq.html#2167" class="Bound">x</a> <a id="2130" class="Symbol">=</a> <a id="2132" class="Keyword">quote</a> <a id="2138" href="Relation.Nullary.Decidable.Core.html#1905" class="InductiveConstructor Operator">_because_</a> <a id="2148" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">◇⟦</a> <a id="2151" class="Keyword">quote</a> <a id="2157" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="2163" href="Reflection.Syntax.html#3281" class="InductiveConstructor Operator">◇</a> <a id="2165" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">∣</a> <a id="2167" href="Tactic.Derive.DecEq.html#2167" class="Bound">x</a> <a id="2169" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">⟧</a>

  <a id="2174" class="Keyword">module</a> <a id="2181" href="Tactic.Derive.DecEq.html#2181" class="Module">_</a> <a id="2183" class="Symbol">(</a><a id="2184" href="Tactic.Derive.DecEq.html#2184" class="Bound">transName</a> <a id="2194" class="Symbol">:</a> <a id="2196" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="2201" class="Symbol">→</a> <a id="2203" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2209" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="2213" class="Symbol">)</a> <a id="2215" class="Keyword">where</a>

    <a id="2226" href="Tactic.Derive.DecEq.html#2226" class="Function">eqFromTerm</a> <a id="2237" class="Symbol">:</a> <a id="2239" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2244" class="Symbol">→</a> <a id="2246" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2251" class="Symbol">→</a> <a id="2253" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2258" class="Symbol">→</a> <a id="2260" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2269" href="Tactic.Derive.DecEq.html#2226" class="Function">eqFromTerm</a> <a id="2280" class="Symbol">(</a><a id="2281" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2285" href="Tactic.Derive.DecEq.html#2285" class="Bound">n</a> <a id="2287" class="Symbol">_)</a> <a id="2290" href="Tactic.Derive.DecEq.html#2290" class="Bound">t</a> <a id="2292" href="Tactic.Derive.DecEq.html#2292" class="Bound">t&#39;</a> <a id="2295" class="Keyword">with</a> <a id="2300" href="Tactic.Derive.DecEq.html#2184" class="Bound">transName</a> <a id="2310" href="Tactic.Derive.DecEq.html#2285" class="Bound">n</a>
    <a id="2316" class="Symbol">...</a> <a id="2320" class="Symbol">|</a> <a id="2322" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2327" href="Tactic.Derive.DecEq.html#2327" class="Bound">n&#39;</a>     <a id="2334" class="Symbol">=</a> <a id="2336" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2340" class="Symbol">(</a><a id="2341" class="Keyword">quote</a> <a id="2347" href="Class.DecEq.Core.html#159" class="Field Operator">_≟_</a><a id="2350" class="Symbol">)</a> <a id="2352" class="Symbol">(</a><a id="2353" href="Reflection.AST.Argument.html#1453" class="InductiveConstructor">iArg</a> <a id="2358" class="Symbol">(</a><a id="2359" href="Tactic.Derive.DecEq.html#2327" class="Bound">n&#39;</a> <a id="2362" href="Reflection.Syntax.html#2900" class="InductiveConstructor Operator">∙</a><a id="2363" class="Symbol">)</a> <a id="2365" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2367" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="2372" class="Bound">t</a> <a id="2374" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2376" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="2381" class="Bound">t&#39;</a> <a id="2384" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2386" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2388" class="Symbol">)</a>
    <a id="2394" class="Symbol">...</a> <a id="2398" class="Symbol">|</a> <a id="2400" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>     <a id="2412" class="Symbol">=</a> <a id="2414" class="Keyword">quote</a> <a id="2420" href="Class.DecEq.Core.html#159" class="Field Operator">_≟_</a> <a id="2424" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">∙⟦</a> <a id="2427" class="Bound">t</a> <a id="2429" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">∣</a> <a id="2431" class="Bound">t&#39;</a> <a id="2434" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">⟧</a>
    <a id="2440" href="Tactic.Derive.DecEq.html#2226" class="CatchallClause Function">eqFromTerm</a><a id="2450" class="CatchallClause"> </a><a id="2451" class="CatchallClause Symbol">_</a><a id="2452" class="CatchallClause"> </a><a id="2453" href="Tactic.Derive.DecEq.html#2453" class="CatchallClause Bound">t</a><a id="2454" class="CatchallClause"> </a><a id="2455" href="Tactic.Derive.DecEq.html#2455" class="CatchallClause Bound">t&#39;</a> <a id="2458" class="Symbol">=</a> <a id="2460" class="Keyword">quote</a> <a id="2466" href="Class.DecEq.Core.html#159" class="Field Operator">_≟_</a> <a id="2470" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">∙⟦</a> <a id="2473" href="Tactic.Derive.DecEq.html#2453" class="Bound">t</a> <a id="2475" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">∣</a> <a id="2477" href="Tactic.Derive.DecEq.html#2455" class="Bound">t&#39;</a> <a id="2480" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">⟧</a>

    <a id="2487" class="Comment">-- `nothing`: outside of the diagonal, not equal</a>
    <a id="2540" class="Comment">-- `just`: on the diagonal, with that pattern, could be equal</a>
    <a id="2606" class="Comment">-- assume that the types in the pattern are properly normalized</a>
    <a id="2674" href="Tactic.Derive.DecEq.html#2674" class="Function">genBranch</a> <a id="2684" class="Symbol">:</a> <a id="2686" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2692" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="2706" class="Symbol">→</a> <a id="2708" href="Reflection.TCI.html#554" class="Function">TC</a> <a id="2711" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2720" href="Tactic.Derive.DecEq.html#2674" class="Function">genBranch</a> <a id="2730" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>         <a id="2746" class="Symbol">=</a> <a id="2748" href="Class.Monad.Core.html#278" class="Field">return</a> <a id="2755" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2757" href="Reflection.QuotedDefinitions.html#498" class="Function">`no</a> <a id="2761" href="Reflection.Syntax.html#2485" class="InductiveConstructor Operator">`λ⦅</a> <a id="2765" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="2767" class="Symbol">(</a><a id="2768" class="String">&quot;&quot;</a> <a id="2771" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2773" href="Reflection.Syntax.html#1381" class="InductiveConstructor">vArg?</a><a id="2778" class="Symbol">)</a> <a id="2780" href="Data.List.Base.html#5205" class="Function Operator">]</a> <a id="2782" href="Reflection.Syntax.html#2485" class="InductiveConstructor Operator">⦆∅</a>
    <a id="2789" href="Tactic.Derive.DecEq.html#2674" class="Function">genBranch</a> <a id="2799" class="Symbol">(</a><a id="2800" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2805" class="Symbol">(</a><a id="2806" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2809" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2811" class="Symbol">_))</a> <a id="2815" class="Symbol">=</a> <a id="2817" href="Class.Monad.Core.html#278" class="Field">return</a> <a id="2824" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="2826" href="Reflection.QuotedDefinitions.html#493" class="Function">`yes</a> <a id="2831" href="Reflection.QuotedDefinitions.html#285" class="Function">`refl</a>
    <a id="2841" href="Tactic.Derive.DecEq.html#2674" class="Function">genBranch</a> <a id="2851" class="Symbol">(</a><a id="2852" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2857" href="Tactic.Derive.DecEq.html#2857" class="Bound">p</a><a id="2858" class="Symbol">@(</a><a id="2860" href="Tactic.Derive.DecEq.html#2860" class="Bound">l</a><a id="2861" class="Symbol">@(</a><a id="2863" href="Tactic.Derive.DecEq.html#2863" class="Bound">x</a> <a id="2865" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2867" href="Tactic.Derive.DecEq.html#2867" class="Bound">xs</a><a id="2869" class="Symbol">)</a> <a id="2871" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2873" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="2877" class="Symbol">_</a> <a id="2879" href="Tactic.Derive.DecEq.html#2879" class="Bound">pat</a><a id="2882" class="Symbol">))</a> <a id="2885" class="Symbol">=</a> <a id="2887" class="Keyword">do</a>
      <a id="2896" class="Symbol">(</a><a id="2897" href="Agda.Builtin.Reflection.html#5814" class="InductiveConstructor">con</a> <a id="2901" href="Tactic.Derive.DecEq.html#2901" class="Bound">n</a> <a id="2903" href="Tactic.Derive.DecEq.html#2903" class="Bound">args</a><a id="2907" class="Symbol">)</a> <a id="2909" href="Class.Monad.Core.html#299" class="Field Operator">←</a> <a id="2911" href="Class.Monad.Core.html#278" class="Field">return</a> <a id="2918" href="Tactic.Derive.DecEq.html#2879" class="Bound">pat</a>
        <a id="2930" class="Keyword">where</a> <a id="2936" class="CatchallClause Symbol">_</a> <a id="2938" class="Symbol">→</a> <a id="2940" href="Class.MonadTC.html#11197" class="Function">error1</a> <a id="2947" class="String">&quot;BUG: genBranch&quot;</a>
      <a id="2970" href="Tactic.Derive.DecEq.html#2970" class="Bound">typeList</a> <a id="2979" href="Class.Monad.Core.html#299" class="Field Operator">←</a> <a id="2981" href="Class.Traversable.Core.html#297" class="Function">traverse</a> <a id="2990" href="Class.MonadTC.html#1736" class="Field">inferType</a> <a id="3000" class="Symbol">(</a><a id="3001" href="Data.List.Base.html#6208" class="Function">applyUpTo</a> <a id="3011" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a> <a id="3013" class="Symbol">(</a><a id="3014" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3021" href="Tactic.Derive.DecEq.html#2860" class="Bound">l</a><a id="3022" class="Symbol">))</a>
      <a id="3031" class="Keyword">let</a> <a id="3035" href="Tactic.Derive.DecEq.html#3035" class="Bound">info</a> <a id="3040" class="Symbol">=</a> <a id="3042" href="Data.List.Base.html#3506" class="Function">L.zip</a> <a id="3048" href="Tactic.Derive.DecEq.html#2970" class="Bound">typeList</a> <a id="3057" class="Symbol">(</a><a id="3058" href="Data.List.Base.html#6728" class="Function">downFrom</a> <a id="3067" class="Symbol">(</a><a id="3068" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3075" href="Tactic.Derive.DecEq.html#2860" class="Bound">l</a><a id="3076" class="Symbol">))</a>
      <a id="3085" class="Keyword">let</a> <a id="3089" href="Tactic.Derive.DecEq.html#3089" class="Bound">ty</a> <a id="3092" class="Symbol">=</a> <a id="3094" class="Keyword">quote</a> <a id="3100" href="Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="3104" href="Reflection.Syntax.html#2924" class="InductiveConstructor Operator">∙⟦</a> <a id="3107" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="3111" href="Tactic.Derive.DecEq.html#2901" class="Bound">n</a> <a id="3113" class="Symbol">(</a><a id="3114" href="Data.List.Base.html#6320" class="Function">applyDownFrom</a> <a id="3128" class="Symbol">(</a><a id="3129" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="3134" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3136" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a> <a id="3138" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3140" class="Symbol">(</a><a id="3141" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="3144" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3151" href="Tactic.Derive.DecEq.html#2860" class="Bound">l</a><a id="3152" class="Symbol">))</a> <a id="3155" class="Symbol">(</a><a id="3156" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3163" href="Tactic.Derive.DecEq.html#2860" class="Bound">l</a><a id="3164" class="Symbol">))</a>
                         <a id="3192" href="Reflection.QuotedDefinitions.html#156" class="Function Operator">`≡</a> <a id="3195" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="3199" href="Tactic.Derive.DecEq.html#2901" class="Bound">n</a> <a id="3201" class="Symbol">(</a><a id="3202" href="Data.List.Base.html#6320" class="Function">applyDownFrom</a> <a id="3216" class="Symbol">(</a><a id="3217" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="3222" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="3224" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a><a id="3225" class="Symbol">)</a> <a id="3227" class="Symbol">(</a><a id="3228" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3235" href="Tactic.Derive.DecEq.html#2860" class="Bound">l</a><a id="3236" class="Symbol">))</a> <a id="3239" href="Reflection.Syntax.html#2924" class="InductiveConstructor Operator">⟧</a>
      <a id="3247" href="Class.Monad.Core.html#278" class="Field">return</a> <a id="3254" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="3256" href="Data.List.Base.html#4249" class="Function">foldl</a> <a id="3262" class="Symbol">(λ</a> <a id="3265" href="Tactic.Derive.DecEq.html#3265" class="Bound">t</a> <a id="3267" class="Symbol">(</a><a id="3268" href="Tactic.Derive.DecEq.html#3268" class="Bound">eq</a> <a id="3271" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3273" href="Tactic.Derive.DecEq.html#3273" class="Bound">k</a><a id="3274" class="Symbol">)</a> <a id="3276" class="Symbol">→</a> <a id="3278" href="Tactic.Derive.DecEq.html#3676" class="Function">genCase</a> <a id="3286" class="Symbol">(</a><a id="3287" href="Reflection.AST.DeBruijn.html#1479" class="Function">weaken</a> <a id="3294" href="Tactic.Derive.DecEq.html#3273" class="Bound">k</a> <a id="3296" href="Tactic.Derive.DecEq.html#3089" class="Bound">ty</a><a id="3298" class="Symbol">)</a> <a id="3300" class="Symbol">(</a><a id="3301" href="Tactic.Derive.DecEq.html#2226" class="Function">eqFromTerm</a> <a id="3312" href="Tactic.Derive.DecEq.html#3268" class="Bound">eq</a><a id="3314" class="Symbol">)</a> <a id="3316" href="Tactic.Derive.DecEq.html#3265" class="Bound">t</a><a id="3317" class="Symbol">)</a> <a id="3319" href="Tactic.Derive.DecEq.html#4447" class="Function">genTrueCase</a> <a id="3331" href="Tactic.Derive.DecEq.html#3035" class="Bound">info</a>
      <a id="3342" class="Keyword">where</a>
        <a id="3356" href="Tactic.Derive.DecEq.html#3356" class="Function">k</a> <a id="3358" class="Symbol">=</a> <a id="3360" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a> <a id="3366" class="Symbol">(</a><a id="3367" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3374" href="Tactic.Derive.DecEq.html#2867" class="Bound">xs</a><a id="3376" class="Symbol">)</a>

        <a id="3387" href="Tactic.Derive.DecEq.html#3387" class="Function">vars</a> <a id="3392" class="Symbol">:</a> <a id="3394" href="Data.List.NonEmpty.Base.html#1229" class="Record">NE.List⁺</a> <a id="3403" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
        <a id="3413" href="Tactic.Derive.DecEq.html#3387" class="Function">vars</a> <a id="3418" class="Symbol">=</a> <a id="3420" class="Number">0</a> <a id="3422" href="Data.List.NonEmpty.Base.html#1275" class="InductiveConstructor Operator">NE.∷</a> <a id="3427" href="Data.List.Base.html#6208" class="Function">applyUpTo</a> <a id="3437" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a> <a id="3443" class="Symbol">(</a><a id="3444" href="Data.List.Base.html#5044" class="Function">length</a> <a id="3451" href="Tactic.Derive.DecEq.html#2867" class="Bound">xs</a><a id="3453" class="Symbol">)</a>

        <a id="3464" class="Comment">-- case (xᵢ ≟ yᵢ) of λ { (false because ...) → no ... ; (true because p) → t }</a>
        <a id="3551" class="Comment">-- since we always add one variable to the scope of t the uncompared terms</a>
        <a id="3634" class="Comment">-- are always at index 2k+1 and k</a>
        <a id="3676" href="Tactic.Derive.DecEq.html#3676" class="Function">genCase</a> <a id="3684" class="Symbol">:</a> <a id="3686" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3691" class="Symbol">→</a> <a id="3693" class="Symbol">(</a><a id="3694" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3699" class="Symbol">→</a> <a id="3701" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3706" class="Symbol">→</a> <a id="3708" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3712" class="Symbol">)</a> <a id="3714" class="Symbol">→</a> <a id="3716" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3721" class="Symbol">→</a> <a id="3723" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="3736" href="Tactic.Derive.DecEq.html#3676" class="Function">genCase</a> <a id="3744" href="Tactic.Derive.DecEq.html#3744" class="Bound">goalTy</a> <a id="3751" href="Tactic.Derive.DecEq.html#3751" class="Bound Operator">_`≟_</a> <a id="3756" href="Tactic.Derive.DecEq.html#3756" class="Bound">t</a> <a id="3758" class="Symbol">=</a> <a id="3760" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">`case</a> <a id="3766" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a> <a id="3768" class="Symbol">(</a><a id="3769" class="Number">2</a> <a id="3771" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="3773" href="Tactic.Derive.DecEq.html#3356" class="Function">k</a> <a id="3775" href="Data.Nat.Base.html#4462" class="Primitive Operator">∸</a> <a id="3777" class="Number">1</a><a id="3778" class="Symbol">)</a> <a id="3780" href="Tactic.Derive.DecEq.html#3751" class="Bound Operator">`≟</a> <a id="3783" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a> <a id="3785" class="Symbol">(</a><a id="3786" href="Tactic.Derive.DecEq.html#3356" class="Function">k</a> <a id="3788" href="Data.Nat.Base.html#4462" class="Primitive Operator">∸</a> <a id="3790" class="Number">1</a><a id="3791" class="Symbol">)</a>
          <a id="3803" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">returning</a> <a id="3813" href="Tactic.Derive.DecEq.html#3744" class="Bound">goalTy</a>
          <a id="3830" href="Tactic.Derive.DecEq.html#1000" class="Function Operator">of</a> <a id="3833" href="Tactic.ClauseBuilder.html#7629" class="Function">clauseExprToPatLam</a> <a id="3852" class="Symbol">(</a><a id="3853" href="Tactic.ClauseBuilder.html#5820" class="InductiveConstructor">MatchExpr</a>
          <a id="3873" class="Symbol">(</a> <a id="3875" class="Symbol">(</a><a id="3876" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="3901" class="Symbol">(</a><a id="3902" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="3907" class="Symbol">(</a><a id="3908" href="Tactic.Derive.DecEq.html#2061" class="InductiveConstructor">``yes&#39;</a> <a id="3915" class="Symbol">(</a><a id="3916" href="Reflection.Syntax.html#1582" class="InductiveConstructor Operator">`</a> <a id="3918" class="Number">0</a><a id="3919" class="Symbol">)))</a> <a id="3923" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3925" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="3930" class="Symbol">(</a><a id="3931" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="3936" href="Tactic.Derive.DecEq.html#3756" class="Bound">t</a><a id="3937" class="Symbol">))</a>
          <a id="3950" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3952" class="Symbol">(</a><a id="3953" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="3978" class="Symbol">(</a><a id="3979" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="3984" class="Symbol">(</a><a id="3985" href="Tactic.Derive.DecEq.html#2121" class="InductiveConstructor">``no&#39;</a>  <a id="3992" class="Symbol">(</a><a id="3993" href="Reflection.Syntax.html#1582" class="InductiveConstructor Operator">`</a> <a id="3995" class="Number">0</a><a id="3996" class="Symbol">)))</a> <a id="4000" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4002" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4007" class="Symbol">(</a><a id="4008" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4013" class="Symbol">(</a><a id="4014" href="Reflection.QuotedDefinitions.html#498" class="Function">`no</a> <a id="4018" href="Function.Base.html#1974" class="Function Operator">$</a>
              <a id="4034" class="Comment">-- case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl</a>
              <a id="4094" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">`case</a> <a id="4100" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a> <a id="4102" class="Number">0</a> <a id="4104" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">of</a> <a id="4107" href="Tactic.ClauseBuilder.html#7629" class="Function">clauseExprToPatLam</a> <a id="4126" class="Symbol">(</a><a id="4127" href="Tactic.ClauseBuilder.html#5895" class="Function">multiClauseExpr</a>
                <a id="4159" href="Data.List.Base.html#5205" class="Function Operator">[</a><a id="4160" class="Symbol">(</a>     <a id="4166" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="4191" class="Symbol">(</a><a id="4192" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="4197" class="Symbol">(</a><a id="4198" class="Keyword">quote</a> <a id="4204" href="Relation.Nullary.Reflects.html#1091" class="InductiveConstructor">ofⁿ</a> <a id="4208" href="Reflection.Syntax.html#3313" class="InductiveConstructor Operator">◇⟦</a> <a id="4211" href="Reflection.Syntax.html#1582" class="InductiveConstructor Operator">`</a> <a id="4213" class="Number">0</a> <a id="4215" href="Reflection.Syntax.html#3313" class="InductiveConstructor Operator">⟧</a><a id="4216" class="Symbol">))</a>
                  <a id="4237" href="Data.List.NonEmpty.Base.html#1275" class="InductiveConstructor Operator">NE.∷</a> <a id="4242" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="4267" class="Symbol">(</a><a id="4268" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="4273" href="Reflection.QuotedDefinitions.html#328" class="InductiveConstructor">``refl</a><a id="4279" class="Symbol">)</a> <a id="4281" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4283" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
                  <a id="4304" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4306" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4311" class="Symbol">(</a><a id="4312" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4317" href="Reflection.Syntax.html#1476" class="InductiveConstructor Operator">♯</a> <a id="4319" class="Number">0</a> <a id="4321" href="Reflection.Syntax.html#1476" class="InductiveConstructor Operator">⟦</a> <a id="4323" href="Reflection.QuotedDefinitions.html#285" class="Function">`refl</a> <a id="4329" href="Reflection.Syntax.html#1476" class="InductiveConstructor Operator">⟧</a><a id="4330" class="Symbol">))</a> <a id="4333" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4334" class="Symbol">))))</a>
          <a id="4349" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4351" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4353" class="Symbol">))</a>

        <a id="4365" class="Comment">-- yes (case p₁ , ... , pₖ of λ where (ofʸ refl , ... , ofʸ refl) → refl)</a>
        <a id="4447" href="Tactic.Derive.DecEq.html#4447" class="Function">genTrueCase</a> <a id="4459" class="Symbol">:</a> <a id="4461" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="4474" href="Tactic.Derive.DecEq.html#4447" class="Function">genTrueCase</a> <a id="4486" class="Symbol">=</a> <a id="4488" href="Reflection.QuotedDefinitions.html#493" class="Function">`yes</a> <a id="4493" href="Function.Base.html#1974" class="Function Operator">$</a>
          <a id="4505" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">`case</a> <a id="4511" href="Data.List.NonEmpty.Base.html#3232" class="Function">NE.foldl₁</a> <a id="4521" class="Symbol">(</a><a id="4522" class="Keyword">quote</a> <a id="4528" href="Data.Product.Base.html#1686" class="Function Operator">_,′_</a> <a id="4533" href="Reflection.Syntax.html#2964" class="InductiveConstructor Operator">∙⟦_∣_⟧</a><a id="4539" class="Symbol">)</a> <a id="4541" class="Symbol">(</a><a id="4542" href="Data.List.NonEmpty.Base.html#2276" class="Function">NE.map</a> <a id="4549" href="Reflection.Syntax.html#1453" class="InductiveConstructor">♯</a> <a id="4551" href="Tactic.Derive.DecEq.html#3387" class="Function">vars</a><a id="4555" class="Symbol">)</a>
           <a id="4568" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">of</a> <a id="4571" href="Tactic.ClauseBuilder.html#7629" class="Function">clauseExprToPatLam</a> <a id="4590" class="Symbol">(</a><a id="4591" href="Tactic.ClauseBuilder.html#5820" class="InductiveConstructor">MatchExpr</a>
             <a id="4614" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="4616" class="Symbol">(</a><a id="4617" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a>
                 <a id="4659" class="Symbol">(</a><a id="4660" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="4665" class="Symbol">(</a><a id="4666" href="Data.List.NonEmpty.Base.html#3232" class="Function">NE.foldl₁</a> <a id="4676" class="Symbol">(</a><a id="4677" class="Keyword">quote</a> <a id="4683" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="4687" href="Reflection.Syntax.html#3361" class="InductiveConstructor Operator">◇⟦_∣_⟧</a><a id="4693" class="Symbol">)</a> <a id="4695" class="Symbol">(</a><a id="4696" href="Data.List.NonEmpty.Base.html#2276" class="Function">NE.map</a> <a id="4703" class="Symbol">(λ</a> <a id="4706" href="Tactic.Derive.DecEq.html#4706" class="Bound">_</a> <a id="4708" class="Symbol">→</a> <a id="4710" class="Keyword">quote</a> <a id="4716" href="Relation.Nullary.Reflects.html#1054" class="InductiveConstructor">ofʸ</a> <a id="4720" href="Reflection.Syntax.html#3313" class="InductiveConstructor Operator">◇⟦</a> <a id="4723" href="Reflection.QuotedDefinitions.html#328" class="InductiveConstructor">``refl</a> <a id="4730" href="Reflection.Syntax.html#3313" class="InductiveConstructor Operator">⟧</a><a id="4731" class="Symbol">)</a> <a id="4733" href="Tactic.Derive.DecEq.html#3387" class="Function">vars</a><a id="4737" class="Symbol">)))</a>
             <a id="4754" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4756" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4761" class="Symbol">(</a><a id="4762" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4767" href="Reflection.QuotedDefinitions.html#285" class="Function">`refl</a><a id="4772" class="Symbol">))</a> <a id="4775" href="Data.List.Base.html#5205" class="Function Operator">]</a><a id="4776" class="Symbol">)</a>

    <a id="4783" href="Tactic.Derive.DecEq.html#4783" class="Function">toMapDiag</a> <a id="4793" class="Symbol">:</a> <a id="4795" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="4809" class="Symbol">→</a> <a id="4811" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="4825" class="Symbol">→</a> <a id="4827" href="Data.List.NonEmpty.Base.html#1229" class="Record">NE.List⁺</a> <a id="4836" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="4850" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="4852" href="Reflection.TCI.html#554" class="Function">TC</a> <a id="4855" class="Symbol">(</a><a id="4856" href="Tactic.ClauseBuilder.html#5795" class="Datatype">ClauseExpr</a> <a id="4867" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="4869" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="4875" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4879" class="Symbol">)</a>
    <a id="4885" href="Tactic.Derive.DecEq.html#4783" class="Function">toMapDiag</a> <a id="4895" href="Tactic.Derive.DecEq.html#4895" class="Bound">p</a><a id="4896" class="Symbol">@(_</a> <a id="4900" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4902" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4906" class="Symbol">_</a> <a id="4908" href="Tactic.Derive.DecEq.html#4908" class="Bound">p₁</a><a id="4910" class="Symbol">)</a> <a id="4912" href="Tactic.Derive.DecEq.html#4912" class="Bound">p&#39;</a><a id="4914" class="Symbol">@(_</a> <a id="4918" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4920" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4924" class="Symbol">_</a> <a id="4926" href="Tactic.Derive.DecEq.html#4926" class="Bound">p₂</a><a id="4928" class="Symbol">)</a> <a id="4930" class="Symbol">=</a>
      <a id="4938" class="Symbol">(</a><a id="4939" href="Tactic.Derive.DecEq.html#4895" class="Bound">p</a> <a id="4941" href="Data.List.NonEmpty.Base.html#1275" class="InductiveConstructor Operator">NE.∷</a> <a id="4946" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="4948" href="Tactic.Derive.DecEq.html#4912" class="Bound">p&#39;</a> <a id="4951" href="Data.List.Base.html#5205" class="Function Operator">]</a> <a id="4953" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4955" href="Tactic.ClauseBuilder.html#12860" class="Function">finishMatch</a> <a id="4967" class="Symbol">(</a><a id="4968" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="4971" href="Relation.Nullary.Decidable.Core.html#4636" class="Function Operator">⌊</a> <a id="4973" href="Tactic.Derive.DecEq.html#4908" class="Bound">p₁</a> <a id="4976" href="Reflection.AST.Term.html#5709" class="Function Operator">≟-Pattern</a> <a id="4986" href="Tactic.Derive.DecEq.html#4926" class="Bound">p₂</a> <a id="4989" href="Relation.Nullary.Decidable.Core.html#4636" class="Function Operator">⌋</a> <a id="4991" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="4996" href="Tactic.Derive.DecEq.html#2674" class="Function">genBranch</a> <a id="5006" class="Symbol">(</a><a id="5007" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="5012" href="Tactic.Derive.DecEq.html#4895" class="Bound">p</a><a id="5013" class="Symbol">)</a> <a id="5015" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="5020" href="Tactic.Derive.DecEq.html#2674" class="Function">genBranch</a> <a id="5030" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="5037" class="Symbol">))</a>

<a id="5041" class="Keyword">module</a> <a id="5048" href="Tactic.Derive.DecEq.html#5048" class="Module">_</a> <a id="5050" class="Symbol">⦃</a> <a id="5052" href="Tactic.Derive.DecEq.html#5052" class="Bound">_</a> <a id="5054" class="Symbol">:</a> <a id="5056" href="Class.MonadTC.html#620" class="Record">TCOptions</a> <a id="5066" class="Symbol">⦄</a> <a id="5068" class="Keyword">where</a>
  <a id="5076" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="5089" class="Symbol">:</a> <a id="5091" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5096" class="Symbol">(</a><a id="5097" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="5102" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5104" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="5108" class="Symbol">)</a> <a id="5110" class="Symbol">→</a> <a id="5112" href="Reflection.Tactic.html#476" class="Function">UnquoteDecl</a>
  <a id="5126" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="5139" class="Symbol">=</a> <a id="5141" href="Tactic.Derive.html#5784" class="Function">derive-Class</a> <a id="5154" class="Number">0</a> <a id="5156" class="Symbol">(λ</a> <a id="5159" href="Tactic.Derive.DecEq.html#5159" class="Bound">transName</a> <a id="5169" href="Tactic.Derive.DecEq.html#5169" class="Bound">ps</a> <a id="5172" class="Symbol">→</a> <a id="5174" href="Data.List.Base.html#2132" class="Function">cartesianProductWith</a> <a id="5195" class="Symbol">(</a><a id="5196" href="Tactic.Derive.DecEq.html#4783" class="Function">toMapDiag</a> <a id="5206" href="Tactic.Derive.DecEq.html#5159" class="Bound">transName</a><a id="5215" class="Symbol">)</a> <a id="5217" href="Tactic.Derive.DecEq.html#5169" class="Bound">ps</a> <a id="5220" href="Tactic.Derive.DecEq.html#5169" class="Bound">ps</a><a id="5222" class="Symbol">)</a>

<a id="5225" class="Keyword">private</a>
  <a id="5235" class="Keyword">open</a> <a id="5240" class="Keyword">import</a> <a id="5247" href="Tactic.Derive.TestTypes.html" class="Module">Tactic.Derive.TestTypes</a>
  <a id="5273" class="Keyword">open</a> <a id="5278" class="Keyword">import</a> <a id="5285" href="Tactic.Defaults.html" class="Module">Tactic.Defaults</a>

  <a id="5304" class="Keyword">unquoteDecl</a> <a id="DecEq-These"></a><a id="5316" href="Tactic.Derive.DecEq.html#5316" class="Function">DecEq-These</a> <a id="5328" class="Symbol">=</a> <a id="5330" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="5343" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="5345" class="Symbol">(</a><a id="5346" class="Keyword">quote</a> <a id="5352" href="Data.These.Base.html#537" class="Datatype">These</a> <a id="5358" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5360" href="Tactic.Derive.DecEq.html#5316" class="Function">DecEq-These</a><a id="5371" class="Symbol">)</a> <a id="5373" href="Data.List.Base.html#5205" class="Function Operator">]</a>

  <a id="5378" class="Keyword">unquoteDecl</a> <a id="DecEq-⊎"></a><a id="5390" href="Tactic.Derive.DecEq.html#5390" class="Function">DecEq-⊎</a> <a id="5398" class="Symbol">=</a> <a id="5400" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="5413" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="5415" class="Symbol">(</a><a id="5416" class="Keyword">quote</a> <a id="5422" href="Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a> <a id="5426" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5428" href="Tactic.Derive.DecEq.html#5390" class="Function">DecEq-⊎</a><a id="5435" class="Symbol">)</a> <a id="5437" href="Data.List.Base.html#5205" class="Function Operator">]</a>

  <a id="5442" class="Keyword">unquoteDecl</a> <a id="DecEq-Bool"></a><a id="5454" href="Tactic.Derive.DecEq.html#5454" class="Function">DecEq-Bool</a> <a id="DecEq-ℤ"></a><a id="5465" href="Tactic.Derive.DecEq.html#5465" class="Function">DecEq-ℤ</a> <a id="DecEq-List"></a><a id="5473" href="Tactic.Derive.DecEq.html#5473" class="Function">DecEq-List</a> <a id="DecEq-Maybe"></a><a id="5484" href="Tactic.Derive.DecEq.html#5484" class="Function">DecEq-Maybe</a> <a id="DecEq-ℕ"></a><a id="5496" href="Tactic.Derive.DecEq.html#5496" class="Function">DecEq-ℕ</a> <a id="DecEq-Sign"></a><a id="5504" href="Tactic.Derive.DecEq.html#5504" class="Function">DecEq-Sign</a> <a id="DecEq-⊤"></a><a id="5515" href="Tactic.Derive.DecEq.html#5515" class="Function">DecEq-⊤</a> <a id="5523" class="Symbol">=</a> <a id="5525" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="5538" class="Symbol">((</a><a id="5540" class="Keyword">quote</a> <a id="5546" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="5551" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5553" href="Tactic.Derive.DecEq.html#5454" class="Function">DecEq-Bool</a><a id="5563" class="Symbol">)</a> <a id="5565" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5567" class="Symbol">(</a><a id="5568" class="Keyword">quote</a> <a id="5574" href="Agda.Builtin.Int.html#245" class="Datatype">ℤ</a> <a id="5576" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5578" href="Tactic.Derive.DecEq.html#5465" class="Function">DecEq-ℤ</a><a id="5585" class="Symbol">)</a> <a id="5587" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5589" class="Symbol">(</a><a id="5590" class="Keyword">quote</a> <a id="5596" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5601" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5603" href="Tactic.Derive.DecEq.html#5473" class="Function">DecEq-List</a><a id="5613" class="Symbol">)</a> <a id="5615" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5617" class="Symbol">(</a><a id="5618" class="Keyword">quote</a> <a id="5624" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="5630" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5632" href="Tactic.Derive.DecEq.html#5484" class="Function">DecEq-Maybe</a><a id="5643" class="Symbol">)</a> <a id="5645" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5647" class="Symbol">(</a><a id="5648" class="Keyword">quote</a> <a id="5654" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5656" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5658" href="Tactic.Derive.DecEq.html#5496" class="Function">DecEq-ℕ</a><a id="5665" class="Symbol">)</a> <a id="5667" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5669" class="Symbol">(</a><a id="5670" class="Keyword">quote</a> <a id="5676" href="Data.Sign.Base.html#523" class="Datatype">Sign</a> <a id="5681" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5683" href="Tactic.Derive.DecEq.html#5504" class="Function">DecEq-Sign</a><a id="5693" class="Symbol">)</a> <a id="5695" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5697" class="Symbol">(</a><a id="5698" class="Keyword">quote</a> <a id="5704" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="5706" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5708" href="Tactic.Derive.DecEq.html#5515" class="Function">DecEq-⊤</a><a id="5715" class="Symbol">)</a> <a id="5717" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5719" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="5721" class="Symbol">)</a>

  <a id="5726" class="Keyword">unquoteDecl</a> <a id="DecEq-Fin"></a><a id="5738" href="Tactic.Derive.DecEq.html#5738" class="Function">DecEq-Fin</a> <a id="5748" class="Symbol">=</a> <a id="5750" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="5763" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="5765" class="Symbol">(</a><a id="5766" class="Keyword">quote</a> <a id="5772" href="Data.Fin.Base.html#1159" class="Datatype">Fin</a> <a id="5776" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5778" href="Tactic.Derive.DecEq.html#5738" class="Function">DecEq-Fin</a><a id="5787" class="Symbol">)</a> <a id="5789" href="Data.List.Base.html#5205" class="Function Operator">]</a>

  <a id="5794" class="Comment">-- this doesn&#39;t work since the clause builder machinery doesn&#39;t deal</a>
  <a id="5865" class="Comment">-- with absurd patterns yet</a>

  <a id="5896" class="Comment">--unquoteDecl DecEq-Vec = derive-DecEq [ (quote Vec , DecEq-Vec) ]</a>

  <a id="5966" class="Keyword">unquoteDecl</a> <a id="DecEq-E1"></a><a id="5978" href="Tactic.Derive.DecEq.html#5978" class="Function">DecEq-E1</a> <a id="5987" class="Symbol">=</a> <a id="5989" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6002" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="6004" class="Symbol">(</a><a id="6005" class="Keyword">quote</a> <a id="6011" href="Tactic.Derive.TestTypes.html#204" class="Datatype">E1</a> <a id="6014" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6016" href="Tactic.Derive.DecEq.html#5978" class="Function">DecEq-E1</a><a id="6024" class="Symbol">)</a> <a id="6026" href="Data.List.Base.html#5205" class="Function Operator">]</a>
  <a id="6030" class="Keyword">unquoteDecl</a> <a id="DecEq-E2"></a><a id="6042" href="Tactic.Derive.DecEq.html#6042" class="Function">DecEq-E2</a> <a id="6051" class="Symbol">=</a> <a id="6053" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6066" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="6068" class="Symbol">(</a><a id="6069" class="Keyword">quote</a> <a id="6075" href="Tactic.Derive.TestTypes.html#309" class="Datatype">E2</a> <a id="6078" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6080" href="Tactic.Derive.DecEq.html#6042" class="Function">DecEq-E2</a><a id="6088" class="Symbol">)</a> <a id="6090" href="Data.List.Base.html#5205" class="Function Operator">]</a>

  <a id="6095" class="Comment">-- this uses mutual recursion with List E3</a>
  <a id="6140" class="Keyword">unquoteDecl</a> <a id="DecEq-E3"></a><a id="6152" href="Tactic.Derive.DecEq.html#6152" class="Function">DecEq-E3</a> <a id="6161" class="Symbol">=</a> <a id="6163" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6176" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="6178" class="Symbol">(</a><a id="6179" class="Keyword">quote</a> <a id="6185" href="Tactic.Derive.TestTypes.html#387" class="Datatype">E3</a> <a id="6188" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6190" href="Tactic.Derive.DecEq.html#6152" class="Function">DecEq-E3</a><a id="6198" class="Symbol">)</a> <a id="6200" href="Data.List.Base.html#5205" class="Function Operator">]</a>
  <a id="6204" class="Comment">-- unquoteDecl DecEq-E4 = derive-DecEq [ (quote E4 , DecEq-E4) ]</a>

  <a id="6272" class="Keyword">unquoteDecl</a> <a id="DecEq-R1"></a><a id="6284" href="Tactic.Derive.DecEq.html#6284" class="Function">DecEq-R1</a> <a id="6293" class="Symbol">=</a> <a id="6295" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6308" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="6310" class="Symbol">(</a><a id="6311" class="Keyword">quote</a> <a id="6317" href="Tactic.Derive.TestTypes.html#597" class="Record">R1</a> <a id="6320" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6322" href="Tactic.Derive.DecEq.html#6284" class="Function">DecEq-R1</a><a id="6330" class="Symbol">)</a> <a id="6332" href="Data.List.Base.html#5205" class="Function Operator">]</a>
  <a id="6336" class="Keyword">unquoteDecl</a> <a id="DecEq-R2"></a><a id="6348" href="Tactic.Derive.DecEq.html#6348" class="Function">DecEq-R2</a> <a id="6357" class="Symbol">=</a> <a id="6359" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6372" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="6374" class="Symbol">(</a><a id="6375" class="Keyword">quote</a> <a id="6381" href="Tactic.Derive.TestTypes.html#658" class="Record">R2</a> <a id="6384" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6386" href="Tactic.Derive.DecEq.html#6348" class="Function">DecEq-R2</a><a id="6394" class="Symbol">)</a> <a id="6396" href="Data.List.Base.html#5205" class="Function Operator">]</a>
  <a id="6400" class="Keyword">unquoteDecl</a> <a id="DecEq-R20"></a><a id="6412" href="Tactic.Derive.DecEq.html#6412" class="Function">DecEq-R20</a> <a id="6422" class="Symbol">=</a> <a id="6424" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6437" href="Data.List.Base.html#5205" class="Function Operator">[</a> <a id="6439" class="Symbol">(</a><a id="6440" class="Keyword">quote</a> <a id="6446" href="Tactic.Derive.TestTypes.html#807" class="Record">R20</a> <a id="6450" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6452" href="Tactic.Derive.DecEq.html#6412" class="Function">DecEq-R20</a><a id="6461" class="Symbol">)</a> <a id="6463" href="Data.List.Base.html#5205" class="Function Operator">]</a>

  <a id="6468" class="Keyword">unquoteDecl</a> <a id="DecEq-M₁"></a><a id="6480" href="Tactic.Derive.DecEq.html#6480" class="Function">DecEq-M₁</a> <a id="DecEq-M₂"></a><a id="6489" href="Tactic.Derive.DecEq.html#6489" class="Function">DecEq-M₂</a> <a id="6498" class="Symbol">=</a> <a id="6500" href="Tactic.Derive.DecEq.html#5076" class="Function">derive-DecEq</a> <a id="6513" href="Function.Base.html#1974" class="Function Operator">$</a> <a id="6515" class="Symbol">(</a><a id="6516" class="Keyword">quote</a> <a id="6522" href="Tactic.Derive.TestTypes.html#914" class="Datatype">M₁</a> <a id="6525" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6527" href="Tactic.Derive.DecEq.html#6480" class="Function">DecEq-M₁</a><a id="6535" class="Symbol">)</a> <a id="6537" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6539" class="Symbol">(</a><a id="6540" class="Keyword">quote</a> <a id="6546" href="Tactic.Derive.TestTypes.html#928" class="Datatype">M₂</a> <a id="6549" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6551" href="Tactic.Derive.DecEq.html#6489" class="Function">DecEq-M₂</a><a id="6559" class="Symbol">)</a> <a id="6561" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6563" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

  <a id="6569" class="Comment">-- Expected: DecEq-Term DecEq-Product</a>
</pre></body></html>